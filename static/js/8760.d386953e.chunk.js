(()=>{"use strict";var __webpack_modules__={32926:(e,n,t)=>{e.exports=t.p+"static/media/docstring_parser-0.14.1-py3-none-any.09e9874f78981163c899.whl"},92255:(e,n,t)=>{e.exports=t.p+"static/media/jedi-0.18.1-py2.py3-none-any.f3aed62ade402f55fee8.whl"},76205:(e,n,t)=>{e.exports=t.p+"static/media/parso-0.8.3-py2.py3-none-any.07dc2fd16da3af3a942c.whl"},23264:(e,n,t)=>{e.exports=t.p+"static/media/pybricks-3.3.0-py3-none-any.90cf1f7814ace26e5ff8.whl"},1564:(e,n,t)=>{e.exports=t.p+"static/media/pybricks_jedi-1.12.0-py3-none-any.32a778a2022ada4ca360.whl"},64115:(e,n,t)=>{e.exports=t.p+"static/media/typing_extensions-4.2.0-py3-none-any.6b14b344298615d994bc.whl"},75180:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{F:()=>loadPyodide,i:()=>version});const out=eval('const module={exports:{}};\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === "object" || typeof from === "function") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. "__esModule" has not been set), then set\n  // "default" to the CommonJS "module.exports" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);\nvar stdin_exports = {};\n__export(stdin_exports, {\n  loadPyodide: () => De,\n  version: () => k\n});\nmodule.exports = __toCommonJS(stdin_exports);\nvar Q = Object.create;\nvar P = Object.defineProperty;\nvar Z = Object.getOwnPropertyDescriptor;\nvar ee = Object.getOwnPropertyNames;\nvar te = Object.getPrototypeOf, re = Object.prototype.hasOwnProperty;\nvar m = (e, t) => P(e, "name", { value: t, configurable: true }), L = ((e) => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(e, { get: (t, s) => (typeof require < "u" ? require : t)[s] }) : e)(function(e) {\n  if (typeof require < "u")\n    return require.apply(this, arguments);\n  throw new Error(\'Dynamic require of "\' + e + \'" is not supported\');\n});\nvar T = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);\nvar ne = (e, t, s, a) => {\n  if (t && typeof t == "object" || typeof t == "function")\n    for (let o of ee(t))\n      !re.call(e, o) && o !== s && P(e, o, { get: () => t[o], enumerable: !(a = Z(t, o)) || a.enumerable });\n  return e;\n};\nvar ie = (e, t, s) => (s = e != null ? Q(te(e)) : {}, ne(t || !e || !e.__esModule ? P(s, "default", { value: e, enumerable: true }) : s, e));\nvar U = T((x, D) => {\n  (function(e, t) {\n    "use strict";\n    typeof define == "function" && define.amd ? define("stackframe", [], t) : typeof x == "object" ? D.exports = t() : e.StackFrame = t();\n  })(x, function() {\n    "use strict";\n    function e(u) {\n      return !isNaN(parseFloat(u)) && isFinite(u);\n    }\n    m(e, "_isNumber");\n    function t(u) {\n      return u.charAt(0).toUpperCase() + u.substring(1);\n    }\n    m(t, "_capitalize");\n    function s(u) {\n      return function() {\n        return this[u];\n      };\n    }\n    m(s, "_getter");\n    var a = ["isConstructor", "isEval", "isNative", "isToplevel"], o = ["columnNumber", "lineNumber"], r = ["fileName", "functionName", "source"], n = ["args"], c = ["evalOrigin"], i = a.concat(o, r, n, c);\n    function l(u) {\n      if (u)\n        for (var y = 0; y < i.length; y++)\n          u[i[y]] !== void 0 && this["set" + t(i[y])](u[i[y]]);\n    }\n    m(l, "StackFrame"), l.prototype = { getArgs: function() {\n      return this.args;\n    }, setArgs: function(u) {\n      if (Object.prototype.toString.call(u) !== "[object Array]")\n        throw new TypeError("Args must be an Array");\n      this.args = u;\n    }, getEvalOrigin: function() {\n      return this.evalOrigin;\n    }, setEvalOrigin: function(u) {\n      if (u instanceof l)\n        this.evalOrigin = u;\n      else if (u instanceof Object)\n        this.evalOrigin = new l(u);\n      else\n        throw new TypeError("Eval Origin must be an Object or StackFrame");\n    }, toString: function() {\n      var u = this.getFileName() || "", y = this.getLineNumber() || "", g = this.getColumnNumber() || "", b = this.getFunctionName() || "";\n      return this.getIsEval() ? u ? "[eval] (" + u + ":" + y + ":" + g + ")" : "[eval]:" + y + ":" + g : b ? b + " (" + u + ":" + y + ":" + g + ")" : u + ":" + y + ":" + g;\n    } }, l.fromString = m(function(y) {\n      var g = y.indexOf("("), b = y.lastIndexOf(")"), q = y.substring(0, g), K = y.substring(g + 1, b).split(","), N = y.substring(b + 1);\n      if (N.indexOf("@") === 0)\n        var F = /@(.+?)(?::(\\d+))?(?::(\\d+))?$/.exec(N, ""), X = F[1], Y = F[2], J = F[3];\n      return new l({ functionName: q, args: K || void 0, fileName: X, lineNumber: Y || void 0, columnNumber: J || void 0 });\n    }, "StackFrame$$fromString");\n    for (var d = 0; d < a.length; d++)\n      l.prototype["get" + t(a[d])] = s(a[d]), l.prototype["set" + t(a[d])] = /* @__PURE__ */ function(u) {\n        return function(y) {\n          this[u] = !!y;\n        };\n      }(a[d]);\n    for (var p = 0; p < o.length; p++)\n      l.prototype["get" + t(o[p])] = s(o[p]), l.prototype["set" + t(o[p])] = /* @__PURE__ */ function(u) {\n        return function(y) {\n          if (!e(y))\n            throw new TypeError(u + " must be a Number");\n          this[u] = Number(y);\n        };\n      }(o[p]);\n    for (var f = 0; f < r.length; f++)\n      l.prototype["get" + t(r[f])] = s(r[f]), l.prototype["set" + t(r[f])] = /* @__PURE__ */ function(u) {\n        return function(y) {\n          this[u] = String(y);\n        };\n      }(r[f]);\n    return l;\n  });\n});\nvar j = T((O, $) => {\n  (function(e, t) {\n    "use strict";\n    typeof define == "function" && define.amd ? define("error-stack-parser", ["stackframe"], t) : typeof O == "object" ? $.exports = t(U()) : e.ErrorStackParser = t(e.StackFrame);\n  })(O, m(function(t) {\n    "use strict";\n    var s = /(^|@)\\S+:\\d+/, a = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m, o = /^(eval@)?(\\[native code])?$/;\n    return { parse: m(function(n) {\n      if (typeof n.stacktrace < "u" || typeof n["opera#sourceloc"] < "u")\n        return this.parseOpera(n);\n      if (n.stack && n.stack.match(a))\n        return this.parseV8OrIE(n);\n      if (n.stack)\n        return this.parseFFOrSafari(n);\n      throw new Error("Cannot parse given Error object");\n    }, "ErrorStackParser$$parse"), extractLocation: m(function(n) {\n      if (n.indexOf(":") === -1)\n        return [n];\n      var c = /(.+?)(?::(\\d+))?(?::(\\d+))?$/, i = c.exec(n.replace(/[()]/g, ""));\n      return [i[1], i[2] || void 0, i[3] || void 0];\n    }, "ErrorStackParser$$extractLocation"), parseV8OrIE: m(function(n) {\n      var c = n.stack.split(`\n`).filter(function(i) {\n        return !!i.match(a);\n      }, this);\n      return c.map(function(i) {\n        i.indexOf("(eval ") > -1 && (i = i.replace(/eval code/g, "eval").replace(/(\\(eval at [^()]*)|(,.*$)/g, ""));\n        var l = i.replace(/^\\s+/, "").replace(/\\(eval code/g, "(").replace(/^.*?\\s+/, ""), d = l.match(/ (\\(.+\\)$)/);\n        l = d ? l.replace(d[0], "") : l;\n        var p = this.extractLocation(d ? d[1] : l), f = d && l || void 0, u = ["eval", "<anonymous>"].indexOf(p[0]) > -1 ? void 0 : p[0];\n        return new t({ functionName: f, fileName: u, lineNumber: p[1], columnNumber: p[2], source: i });\n      }, this);\n    }, "ErrorStackParser$$parseV8OrIE"), parseFFOrSafari: m(function(n) {\n      var c = n.stack.split(`\n`).filter(function(i) {\n        return !i.match(o);\n      }, this);\n      return c.map(function(i) {\n        if (i.indexOf(" > eval") > -1 && (i = i.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g, ":$1")), i.indexOf("@") === -1 && i.indexOf(":") === -1)\n          return new t({ functionName: i });\n        var l = /((.*".+"[^@]*)?[^@]*)(?:@)/, d = i.match(l), p = d && d[1] ? d[1] : void 0, f = this.extractLocation(i.replace(l, ""));\n        return new t({ functionName: p, fileName: f[0], lineNumber: f[1], columnNumber: f[2], source: i });\n      }, this);\n    }, "ErrorStackParser$$parseFFOrSafari"), parseOpera: m(function(n) {\n      return !n.stacktrace || n.message.indexOf(`\n`) > -1 && n.message.split(`\n`).length > n.stacktrace.split(`\n`).length ? this.parseOpera9(n) : n.stack ? this.parseOpera11(n) : this.parseOpera10(n);\n    }, "ErrorStackParser$$parseOpera"), parseOpera9: m(function(n) {\n      for (var c = /Line (\\d+).*script (?:in )?(\\S+)/i, i = n.message.split(`\n`), l = [], d = 2, p = i.length; d < p; d += 2) {\n        var f = c.exec(i[d]);\n        f && l.push(new t({ fileName: f[2], lineNumber: f[1], source: i[d] }));\n      }\n      return l;\n    }, "ErrorStackParser$$parseOpera9"), parseOpera10: m(function(n) {\n      for (var c = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i, i = n.stacktrace.split(`\n`), l = [], d = 0, p = i.length; d < p; d += 2) {\n        var f = c.exec(i[d]);\n        f && l.push(new t({ functionName: f[3] || void 0, fileName: f[2], lineNumber: f[1], source: i[d] }));\n      }\n      return l;\n    }, "ErrorStackParser$$parseOpera10"), parseOpera11: m(function(n) {\n      var c = n.stack.split(`\n`).filter(function(i) {\n        return !!i.match(s) && !i.match(/^Error created at/);\n      }, this);\n      return c.map(function(i) {\n        var l = i.split("@"), d = this.extractLocation(l.pop()), p = l.shift() || "", f = p.replace(/<anonymous function(: (\\w+))?>/, "$2").replace(/\\([^)]*\\)/g, "") || void 0, u;\n        p.match(/\\(([^)]*)\\)/) && (u = p.replace(/^[^(]+\\(([^)]*)\\)$/, "$1"));\n        var y = u === void 0 || u === "[arguments not available]" ? void 0 : u.split(",");\n        return new t({ functionName: f, args: y, fileName: d[0], lineNumber: d[1], columnNumber: d[2], source: i });\n      }, this);\n    }, "ErrorStackParser$$parseOpera11") };\n  }, "ErrorStackParser"));\n});\nvar V = ie(j());\nvar _ = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string" && typeof process.browser == "undefined", C, w, R, M, A;\nasync function B() {\n  if (!_ || (C = (await import("url")).default, A = await import("fs/promises"), globalThis.fetch ? w = fetch : w = (await import("node-fetch")).default, M = (await import("vm")).default, R = await import("path"), E = R.sep, typeof L != "undefined"))\n    return;\n  let e = await import("fs"), t = await import("crypto"), s = await import("ws"), a = await import("child_process"), o = { fs: e, crypto: t, ws: s, child_process: a };\n  ({});\n}\nm(B, "initNodeModules");\nfunction oe(e, t) {\n  return R.resolve(t || ".", e);\n}\nm(oe, "node_resolvePath");\nfunction ae(e, t) {\n  return t === void 0 && (t = location), new URL(e, t).toString();\n}\nm(ae, "browser_resolvePath");\nvar S;\n_ ? S = oe : S = ae;\nvar E;\n_ || (E = "/");\nfunction se(e, t) {\n  return e.startsWith("file://") && (e = e.slice(7)), e.includes("://") ? { response: w(e) } : { binary: A.readFile(e).then((s) => new Uint8Array(s.buffer, s.byteOffset, s.byteLength)) };\n}\nm(se, "node_getBinaryResponse");\nfunction le(e, t) {\n  let s = new URL(e, location);\n  return { response: fetch(s, t ? { integrity: t } : {}) };\n}\nm(le, "browser_getBinaryResponse");\nvar v;\n_ ? v = se : v = le;\nasync function W(e, t) {\n  let { response: s, binary: a } = v(e, t);\n  if (a)\n    return a;\n  let o = await s;\n  if (!o.ok)\n    throw new Error(`Failed to load \'${e}\': request failed.`);\n  return new Uint8Array(await o.arrayBuffer());\n}\nm(W, "loadBinaryFile");\nvar h;\nif (globalThis.document)\n  h = m(async (e) => await import(e), "loadScript");\nelse if (globalThis.importScripts)\n  h = m(async (e) => {\n    try {\n      globalThis.importScripts(e);\n    } catch (t) {\n      if (t instanceof TypeError)\n        await import(e);\n      else\n        throw t;\n    }\n  }, "loadScript");\nelse if (_)\n  h = de;\nelse\n  throw new Error("Cannot determine runtime environment");\nasync function de(e) {\n  e.startsWith("file://") && (e = e.slice(7)), e.includes("://") ? M.runInThisContext(await (await w(e)).text()) : await import(C.pathToFileURL(e).href);\n}\nm(de, "nodeLoadScript");\nfunction H(e) {\n  let t = e.FS, s = e.FS.filesystems.MEMFS, a = e.PATH, o = { DIR_MODE: 16895, FILE_MODE: 33279, mount: function(r) {\n    if (!r.opts.fileSystemHandle)\n      throw new Error("opts.fileSystemHandle is required");\n    return s.mount.apply(null, arguments);\n  }, syncfs: async (r, n, c) => {\n    try {\n      let i = o.getLocalSet(r), l = await o.getRemoteSet(r), d = n ? l : i, p = n ? i : l;\n      await o.reconcile(r, d, p), c(null);\n    } catch (i) {\n      c(i);\n    }\n  }, getLocalSet: (r) => {\n    let n = /* @__PURE__ */ Object.create(null);\n    function c(d) {\n      return d !== "." && d !== "..";\n    }\n    m(c, "isRealDir");\n    function i(d) {\n      return (p) => a.join2(d, p);\n    }\n    m(i, "toAbsolute");\n    let l = t.readdir(r.mountpoint).filter(c).map(i(r.mountpoint));\n    for (; l.length; ) {\n      let d = l.pop(), p = t.stat(d);\n      t.isDir(p.mode) && l.push.apply(l, t.readdir(d).filter(c).map(i(d))), n[d] = { timestamp: p.mtime, mode: p.mode };\n    }\n    return { type: "local", entries: n };\n  }, getRemoteSet: async (r) => {\n    let n = /* @__PURE__ */ Object.create(null), c = await ce(r.opts.fileSystemHandle);\n    for (let [i, l] of c)\n      i !== "." && (n[a.join2(r.mountpoint, i)] = { timestamp: l.kind === "file" ? (await l.getFile()).lastModifiedDate : /* @__PURE__ */ new Date(), mode: l.kind === "file" ? o.FILE_MODE : o.DIR_MODE });\n    return { type: "remote", entries: n, handles: c };\n  }, loadLocalEntry: (r) => {\n    let c = t.lookupPath(r).node, i = t.stat(r);\n    if (t.isDir(i.mode))\n      return { timestamp: i.mtime, mode: i.mode };\n    if (t.isFile(i.mode))\n      return c.contents = s.getFileDataAsTypedArray(c), { timestamp: i.mtime, mode: i.mode, contents: c.contents };\n    throw new Error("node type not supported");\n  }, storeLocalEntry: (r, n) => {\n    if (t.isDir(n.mode))\n      t.mkdirTree(r, n.mode);\n    else if (t.isFile(n.mode))\n      t.writeFile(r, n.contents, { canOwn: true });\n    else\n      throw new Error("node type not supported");\n    t.chmod(r, n.mode), t.utime(r, n.timestamp, n.timestamp);\n  }, removeLocalEntry: (r) => {\n    var n = t.stat(r);\n    t.isDir(n.mode) ? t.rmdir(r) : t.isFile(n.mode) && t.unlink(r);\n  }, loadRemoteEntry: async (r) => {\n    if (r.kind === "file") {\n      let n = await r.getFile();\n      return { contents: new Uint8Array(await n.arrayBuffer()), mode: o.FILE_MODE, timestamp: n.lastModifiedDate };\n    } else {\n      if (r.kind === "directory")\n        return { mode: o.DIR_MODE, timestamp: /* @__PURE__ */ new Date() };\n      throw new Error("unknown kind: " + r.kind);\n    }\n  }, storeRemoteEntry: async (r, n, c) => {\n    let i = r.get(a.dirname(n)), l = t.isFile(c.mode) ? await i.getFileHandle(a.basename(n), { create: true }) : await i.getDirectoryHandle(a.basename(n), { create: true });\n    if (l.kind === "file") {\n      let d = await l.createWritable();\n      await d.write(c.contents), await d.close();\n    }\n    r.set(n, l);\n  }, removeRemoteEntry: async (r, n) => {\n    await r.get(a.dirname(n)).removeEntry(a.basename(n)), r.delete(n);\n  }, reconcile: async (r, n, c) => {\n    let i = 0, l = [];\n    Object.keys(n.entries).forEach(function(f) {\n      let u = n.entries[f], y = c.entries[f];\n      (!y || t.isFile(u.mode) && u.timestamp.getTime() > y.timestamp.getTime()) && (l.push(f), i++);\n    }), l.sort();\n    let d = [];\n    if (Object.keys(c.entries).forEach(function(f) {\n      n.entries[f] || (d.push(f), i++);\n    }), d.sort().reverse(), !i)\n      return;\n    let p = n.type === "remote" ? n.handles : c.handles;\n    for (let f of l) {\n      let u = a.normalize(f.replace(r.mountpoint, "/")).substring(1);\n      if (c.type === "local") {\n        let y = p.get(u), g = await o.loadRemoteEntry(y);\n        o.storeLocalEntry(f, g);\n      } else {\n        let y = o.loadLocalEntry(f);\n        await o.storeRemoteEntry(p, u, y);\n      }\n    }\n    for (let f of d)\n      if (c.type === "local")\n        o.removeLocalEntry(f);\n      else {\n        let u = a.normalize(f.replace(r.mountpoint, "/")).substring(1);\n        await o.removeRemoteEntry(p, u);\n      }\n  } };\n  e.FS.filesystems.NATIVEFS_ASYNC = o;\n}\nm(H, "initializeNativeFS");\nvar ce = m(async (e) => {\n  let t = [];\n  async function s(o) {\n    for await (let r of o.values())\n      t.push(r), r.kind === "directory" && await s(r);\n  }\n  m(s, "collect"), await s(e);\n  let a = /* @__PURE__ */ new Map();\n  a.set(".", e);\n  for (let o of t) {\n    let r = (await e.resolve(o)).join("/");\n    a.set(r, o);\n  }\n  return a;\n}, "getFsHandles");\nfunction I() {\n  let e = {};\n  return e.noImageDecoding = true, e.noAudioDecoding = true, e.noWasmDecoding = false, e.preRun = [], e.quit = (t, s) => {\n    throw e.exited = { status: t, toThrow: s }, s;\n  }, e;\n}\nm(I, "createModule");\nfunction ue(e, t) {\n  e.preRun.push(function() {\n    let s = "/";\n    try {\n      e.FS.mkdirTree(t);\n    } catch (a) {\n      console.error(`Error occurred while making a home directory \'${t}\':`), console.error(a), console.error(`Using \'${s}\' for a home directory instead`), t = s;\n    }\n    e.FS.chdir(t);\n  });\n}\nm(ue, "createHomeDirectory");\nfunction fe(e, t) {\n  e.preRun.push(function() {\n    Object.assign(e.ENV, t);\n  });\n}\nm(fe, "setEnvironment");\nfunction me(e, t) {\n  e.preRun.push(() => {\n    for (let s of t)\n      e.FS.mkdirTree(s), e.FS.mount(e.FS.filesystems.NODEFS, { root: s }, s);\n  });\n}\nm(me, "mountLocalDirectories");\nfunction pe(e, t) {\n  let s = W(t);\n  e.preRun.push(() => {\n    let a = e._py_version_major(), o = e._py_version_minor();\n    e.FS.mkdirTree("/lib"), e.FS.mkdirTree(`/lib/python${a}.${o}/site-packages`), e.addRunDependency("install-stdlib"), s.then((r) => {\n      e.FS.writeFile(`/lib/python${a}${o}.zip`, r);\n    }).catch((r) => {\n      console.error("Error occurred while installing the standard library:"), console.error(r);\n    }).finally(() => {\n      e.removeRunDependency("install-stdlib");\n    });\n  });\n}\nm(pe, "installStdlib");\nfunction z(e, t) {\n  let s;\n  t.stdLibURL != null ? s = t.stdLibURL : s = t.indexURL + "python_stdlib.zip", pe(e, s), ue(e, t.env.HOME), fe(e, t.env), me(e, t._node_mounts), e.preRun.push(() => H(e));\n}\nm(z, "initializeFileSystem");\nfunction G(e, t) {\n  let { binary: s, response: a } = v(t + "pyodide.asm.wasm");\n  e.instantiateWasm = function(o, r) {\n    return async function() {\n      try {\n        let n;\n        a ? n = await WebAssembly.instantiateStreaming(a, o) : n = await WebAssembly.instantiate(await s, o);\n        let { instance: c, module: i } = n;\n        typeof WasmOffsetConverter != "undefined" && (wasmOffsetConverter = new WasmOffsetConverter(wasmBinary, i)), r(c, i);\n      } catch (n) {\n        console.warn("wasm instantiation failed!"), console.warn(n);\n      }\n    }(), {};\n  };\n}\nm(G, "preloadWasm");\nvar k = "0.24.1";\nfunction ye(e, t) {\n  return new Proxy(e, { get(s, a) {\n    return a === "get" ? (o) => {\n      let r = s.get(o);\n      return r === void 0 && (r = t.get(o)), r;\n    } : a === "has" ? (o) => s.has(o) || t.has(o) : Reflect.get(s, a);\n  } });\n}\nm(ye, "wrapPythonGlobals");\nfunction ge(e, t) {\n  e.runPythonInternal_dict = e._pyodide._base.eval_code("{}"), e.importlib = e.runPythonInternal("import importlib; importlib");\n  let s = e.importlib.import_module;\n  e.sys = s("sys"), e.sys.path.insert(0, t.env.HOME), e.os = s("os");\n  let a = e.runPythonInternal("import __main__; __main__.__dict__"), o = e.runPythonInternal("import builtins; builtins.__dict__");\n  e.globals = ye(a, o);\n  let r = e._pyodide._importhook;\n  function n(i) {\n    "__all__" in i || Object.defineProperty(i, "__all__", { get: () => c.toPy(Object.getOwnPropertyNames(i).filter((l) => l !== "__all__")), enumerable: false, configurable: true });\n  }\n  m(n, "jsFinderHook"), r.register_js_finder.callKwargs({ hook: n }), r.register_js_module("js", t.jsglobals);\n  let c = e.makePublicAPI();\n  return r.register_js_module("pyodide_js", c), e.pyodide_py = s("pyodide"), e.pyodide_code = s("pyodide.code"), e.pyodide_ffi = s("pyodide.ffi"), e.package_loader = s("pyodide._package_loader"), e.sitepackages = e.package_loader.SITE_PACKAGES.__str__(), e.dsodir = e.package_loader.DSO_DIR.__str__(), e.defaultLdLibraryPath = [e.dsodir, e.sitepackages], e.os.environ.__setitem__("LD_LIBRARY_PATH", e.defaultLdLibraryPath.join(":")), c.pyodide_py = e.pyodide_py, c.globals = e.globals, c;\n}\nm(ge, "finalizeBootstrap");\nfunction be() {\n  if (typeof __dirname == "string")\n    return __dirname;\n  let e;\n  try {\n    throw new Error();\n  } catch (a) {\n    e = a;\n  }\n  let t = V.default.parse(e)[0].fileName, s = t.lastIndexOf(E);\n  if (s === -1)\n    throw new Error("Could not extract indexURL path from pyodide module location");\n  return t.slice(0, s);\n}\nm(be, "calculateIndexURL");\nasync function De(e = {}) {\n  await B();\n  let t = e.indexURL || be();\n  t = S(t), t.endsWith("/") || (t += "/"), e.indexURL = t;\n  let s = { fullStdLib: false, jsglobals: globalThis, stdin: globalThis.prompt ? globalThis.prompt : void 0, lockFileURL: t + "pyodide-lock.json", args: [], _node_mounts: [], env: {}, packageCacheDir: t, packages: [] }, a = Object.assign(s, e);\n  if (e.homedir) {\n    if (console.warn("The homedir argument to loadPyodide is deprecated. Use \'env: { HOME: value }\' instead of \'homedir: value\'."), e.env && e.env.HOME)\n      throw new Error("Set both env.HOME and homedir arguments");\n    a.env.HOME = a.homedir;\n  }\n  a.env.HOME || (a.env.HOME = "/home/pyodide");\n  let o = I();\n  o.print = a.stdout, o.printErr = a.stderr, o.arguments = a.args;\n  let r = { config: a };\n  o.API = r, G(o, t), z(o, a);\n  let n = new Promise((f) => o.postRun = f), c;\n  if (r.bootstrapFinalizedPromise = new Promise((f) => c = f), o.locateFile = (f) => a.indexURL + f, typeof _createPyodideModule != "function") {\n    let f = `${a.indexURL}pyodide.asm.js`;\n    await h(f);\n  }\n  if (await _createPyodideModule(o), await n, o.exited)\n    throw o.exited.toThrow;\n  if (r.version !== k)\n    throw new Error(`Pyodide version does not match: \'${k}\' <==> \'${r.version}\'. If you updated the Pyodide version, make sure you also updated the \'indexURL\' parameter passed to loadPyodide.`);\n  o.locateFile = (f) => {\n    throw new Error("Didn\'t expect to load any more file_packager files!");\n  };\n  let [i, l] = r.rawRun("import _pyodide_core");\n  i && o.API.fatal_loading_error(`Failed to import _pyodide_core\n`, l);\n  let d = ge(r, a);\n  if (c(), d.version.includes("dev") || r.setCdnUrl(`https://cdn.jsdelivr.net/pyodide/v${d.version}/full/`), await r.packageIndexReady, r._pyodide._importhook.register_module_not_found_hook(r._import_name_to_package_name, r.lockfile_unvendored_stdlibs_and_test), r.lockfile_info.version !== k)\n    throw new Error("Lock file version doesn\'t match Pyodide version");\n  return r.package_loader.init_loaded_packages(), a.fullStdLib && await d.loadPackage(r.lockfile_unvendored_stdlibs), r.initializeStreams(a.stdin, a.stdout, a.stderr), d;\n}\nm(De, "loadPyodide");\nmodule.exports;\n'),loadPyodide=out.loadPyodide,version=out.version}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var t=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](t,t.exports,__webpack_require__),t.exports}__webpack_require__.m=__webpack_modules__,__webpack_require__.d=(e,n)=>{for(var t in n)__webpack_require__.o(n,t)&&!__webpack_require__.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),__webpack_require__.p="/pybricks-code/",__webpack_require__.b=self.location+"/../../../";var __webpack_exports__={};(()=>{var e=__webpack_require__(75180);function n(e){return function(e){const n=e;return void 0!==n&&"string"===typeof n.name&&"string"===typeof n.message}(e)?e:"string"===typeof e?new Error(e):Error(String(e))}function t(e){const n=e().type;function t(e){return e.type===n}return Object.assign(e,{toString:()=>n,matches:t,when:function(e){return n=>!!t(n)&&e(n)}})}const r=t((()=>({type:"python.message.init"}))),o=t((()=>({type:"python.message.didInit"}))),i=t((e=>({type:"python.message.didFailToInit",error:e}))),a=t((e=>({type:"python.message.setInterruptBuffer",buffer:e}))),s=t(((e,n,t)=>({type:"python.message.complete",code:e,lineNumber:n,column:t}))),l=t((e=>({type:"python.message.didComplete",completionListJson:e}))),c=t((e=>({type:"python.message.didFailToComplete",error:e}))),d=t(((e,n,t)=>({type:"python.message.getSignature",code:e,lineNumber:n,column:t}))),p=t((e=>({type:"python.message.didGetSignature",signatureHelpJson:e}))),u=t((e=>({type:"python.message.didFailToGetSignature",error:e}))),m=t(((e,n)=>({type:"python.message.writeUserFile",path:e,contents:n}))),f=t((e=>({type:"python.message.deleteUserFile",path:e}))),_=t((()=>({type:"python.message.didMountUserFileSystem"})));function y(e){const t=n(e);return function(e){return"PythonError"===e.constructor.name}(t)&&"KeyboardInterrupt"===t.type?new DOMException("cancelled via KeyboardInterrupt","AbortError"):t}function g(e){return e.slice(0,e.length-3).replaceAll("/",".")}self.addEventListener("message",(async t=>{if(r.matches(t.data))try{await async function(){console.log("starting Pyodide...");const n=await(0,e.F)({indexURL:`pyodide/${e.i}`}),t="/user";n.FS.mkdir(t),n.FS.mount(n.FS.filesystems.MEMFS,{root:"."},t);const r=new Set;self.addEventListener("message",(async e=>m.matches(e.data)?(n.FS.writeFile(`${t}/${e.data.path}`,e.data.contents),console.debug("copied",e.data.path,"to emscripten fs"),void r.add(g(e.data.path))):f.matches(e.data)?(n.FS.unlink(`${t}/${e.data.path}`),console.debug("removed",e.data.path," from emscripten fs"),void r.delete(g(e.data.path))):void 0)),self.postMessage(_()),await n.runPythonAsync(`import sys; sys.path.append("${t}")`),await n.loadPackage([new URL(__webpack_require__(32926),__webpack_require__.b).toString(),new URL(__webpack_require__(92255),__webpack_require__.b).toString(),new URL(__webpack_require__(76205),__webpack_require__.b).toString(),new URL(__webpack_require__(1564),__webpack_require__.b).toString(),new URL(__webpack_require__(23264),__webpack_require__.b).toString(),new URL(__webpack_require__(64115),__webpack_require__.b).toString()]),await n.runPythonAsync("\nimport jedi\nimport pybricks_jedi\n\nprint('preloading pybricks_jedi...')\npybricks_jedi.initialize()\n# TODO: this could be moved to pybricks_jedi.initialize()\npybricks_jedi.complete(\"from \", 1, 6)\nprint('preloading done.')\n");const o=n.runPython("pybricks_jedi.complete"),i=n.runPython("pybricks_jedi.get_signatures"),h=n.runPython("pybricks_jedi.update_user_modules");self.addEventListener("message",(async e=>{if(a.matches(e.data))n.setInterruptBuffer(e.data.buffer);else if(s.matches(e.data)){console.debug("worker received complete message");try{h(r);const{code:n,lineNumber:t,column:i}=e.data,a=o(n,t,i);self.postMessage(l(a))}catch(t){self.postMessage(c(y(t)))}}else if(d.matches(e.data)){console.debug("worker received getSignatures message");try{h(r);const{code:n,lineNumber:t,column:o}=e.data,a=i(n,t,o);self.postMessage(p(a))}catch(t){self.postMessage(u(y(t)))}}})),console.log("Pyodide is ready.")}(),postMessage(o())}catch(h){postMessage(i(n(h)))}}))})()})();
//# sourceMappingURL=8760.d386953e.chunk.js.map