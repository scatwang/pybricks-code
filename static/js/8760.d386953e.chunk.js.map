{"version":3,"file":"static/js/8760.d386953e.chunk.js","mappings":"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","sources":["../node_modules/pyodide/pyodide.mjs","../webpack/bootstrap","../webpack/runtime/define property getters","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","utils/index.ts","actions.ts","pybricksMicropython/python-message.ts","pybricksMicropython/python-worker.ts"],"sourcesContent":["const out = eval(\"const module={exports:{}};\\nvar __create = Object.create;\\nvar __defProp = Object.defineProperty;\\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\\nvar __getOwnPropNames = Object.getOwnPropertyNames;\\nvar __getProtoOf = Object.getPrototypeOf;\\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\\nvar __export = (target, all) => {\\n  for (var name in all)\\n    __defProp(target, name, { get: all[name], enumerable: true });\\n};\\nvar __copyProps = (to, from, except, desc) => {\\n  if (from && typeof from === \\\"object\\\" || typeof from === \\\"function\\\") {\\n    for (let key of __getOwnPropNames(from))\\n      if (!__hasOwnProp.call(to, key) && key !== except)\\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\\n  }\\n  return to;\\n};\\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\\n  // If the importer is in node compatibility mode or this is not an ESM\\n  // file that has been converted to a CommonJS file using a Babel-\\n  // compatible transform (i.e. \\\"__esModule\\\" has not been set), then set\\n  // \\\"default\\\" to the CommonJS \\\"module.exports\\\" for node compatibility.\\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \\\"default\\\", { value: mod, enumerable: true }) : target,\\n  mod\\n));\\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \\\"__esModule\\\", { value: true }), mod);\\nvar stdin_exports = {};\\n__export(stdin_exports, {\\n  loadPyodide: () => De,\\n  version: () => k\\n});\\nmodule.exports = __toCommonJS(stdin_exports);\\nvar Q = Object.create;\\nvar P = Object.defineProperty;\\nvar Z = Object.getOwnPropertyDescriptor;\\nvar ee = Object.getOwnPropertyNames;\\nvar te = Object.getPrototypeOf, re = Object.prototype.hasOwnProperty;\\nvar m = (e, t) => P(e, \\\"name\\\", { value: t, configurable: true }), L = ((e) => typeof require < \\\"u\\\" ? require : typeof Proxy < \\\"u\\\" ? new Proxy(e, { get: (t, s) => (typeof require < \\\"u\\\" ? require : t)[s] }) : e)(function(e) {\\n  if (typeof require < \\\"u\\\")\\n    return require.apply(this, arguments);\\n  throw new Error('Dynamic require of \\\"' + e + '\\\" is not supported');\\n});\\nvar T = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);\\nvar ne = (e, t, s, a) => {\\n  if (t && typeof t == \\\"object\\\" || typeof t == \\\"function\\\")\\n    for (let o of ee(t))\\n      !re.call(e, o) && o !== s && P(e, o, { get: () => t[o], enumerable: !(a = Z(t, o)) || a.enumerable });\\n  return e;\\n};\\nvar ie = (e, t, s) => (s = e != null ? Q(te(e)) : {}, ne(t || !e || !e.__esModule ? P(s, \\\"default\\\", { value: e, enumerable: true }) : s, e));\\nvar U = T((x, D) => {\\n  (function(e, t) {\\n    \\\"use strict\\\";\\n    typeof define == \\\"function\\\" && define.amd ? define(\\\"stackframe\\\", [], t) : typeof x == \\\"object\\\" ? D.exports = t() : e.StackFrame = t();\\n  })(x, function() {\\n    \\\"use strict\\\";\\n    function e(u) {\\n      return !isNaN(parseFloat(u)) && isFinite(u);\\n    }\\n    m(e, \\\"_isNumber\\\");\\n    function t(u) {\\n      return u.charAt(0).toUpperCase() + u.substring(1);\\n    }\\n    m(t, \\\"_capitalize\\\");\\n    function s(u) {\\n      return function() {\\n        return this[u];\\n      };\\n    }\\n    m(s, \\\"_getter\\\");\\n    var a = [\\\"isConstructor\\\", \\\"isEval\\\", \\\"isNative\\\", \\\"isToplevel\\\"], o = [\\\"columnNumber\\\", \\\"lineNumber\\\"], r = [\\\"fileName\\\", \\\"functionName\\\", \\\"source\\\"], n = [\\\"args\\\"], c = [\\\"evalOrigin\\\"], i = a.concat(o, r, n, c);\\n    function l(u) {\\n      if (u)\\n        for (var y = 0; y < i.length; y++)\\n          u[i[y]] !== void 0 && this[\\\"set\\\" + t(i[y])](u[i[y]]);\\n    }\\n    m(l, \\\"StackFrame\\\"), l.prototype = { getArgs: function() {\\n      return this.args;\\n    }, setArgs: function(u) {\\n      if (Object.prototype.toString.call(u) !== \\\"[object Array]\\\")\\n        throw new TypeError(\\\"Args must be an Array\\\");\\n      this.args = u;\\n    }, getEvalOrigin: function() {\\n      return this.evalOrigin;\\n    }, setEvalOrigin: function(u) {\\n      if (u instanceof l)\\n        this.evalOrigin = u;\\n      else if (u instanceof Object)\\n        this.evalOrigin = new l(u);\\n      else\\n        throw new TypeError(\\\"Eval Origin must be an Object or StackFrame\\\");\\n    }, toString: function() {\\n      var u = this.getFileName() || \\\"\\\", y = this.getLineNumber() || \\\"\\\", g = this.getColumnNumber() || \\\"\\\", b = this.getFunctionName() || \\\"\\\";\\n      return this.getIsEval() ? u ? \\\"[eval] (\\\" + u + \\\":\\\" + y + \\\":\\\" + g + \\\")\\\" : \\\"[eval]:\\\" + y + \\\":\\\" + g : b ? b + \\\" (\\\" + u + \\\":\\\" + y + \\\":\\\" + g + \\\")\\\" : u + \\\":\\\" + y + \\\":\\\" + g;\\n    } }, l.fromString = m(function(y) {\\n      var g = y.indexOf(\\\"(\\\"), b = y.lastIndexOf(\\\")\\\"), q = y.substring(0, g), K = y.substring(g + 1, b).split(\\\",\\\"), N = y.substring(b + 1);\\n      if (N.indexOf(\\\"@\\\") === 0)\\n        var F = /@(.+?)(?::(\\\\d+))?(?::(\\\\d+))?$/.exec(N, \\\"\\\"), X = F[1], Y = F[2], J = F[3];\\n      return new l({ functionName: q, args: K || void 0, fileName: X, lineNumber: Y || void 0, columnNumber: J || void 0 });\\n    }, \\\"StackFrame$$fromString\\\");\\n    for (var d = 0; d < a.length; d++)\\n      l.prototype[\\\"get\\\" + t(a[d])] = s(a[d]), l.prototype[\\\"set\\\" + t(a[d])] = /* @__PURE__ */ function(u) {\\n        return function(y) {\\n          this[u] = !!y;\\n        };\\n      }(a[d]);\\n    for (var p = 0; p < o.length; p++)\\n      l.prototype[\\\"get\\\" + t(o[p])] = s(o[p]), l.prototype[\\\"set\\\" + t(o[p])] = /* @__PURE__ */ function(u) {\\n        return function(y) {\\n          if (!e(y))\\n            throw new TypeError(u + \\\" must be a Number\\\");\\n          this[u] = Number(y);\\n        };\\n      }(o[p]);\\n    for (var f = 0; f < r.length; f++)\\n      l.prototype[\\\"get\\\" + t(r[f])] = s(r[f]), l.prototype[\\\"set\\\" + t(r[f])] = /* @__PURE__ */ function(u) {\\n        return function(y) {\\n          this[u] = String(y);\\n        };\\n      }(r[f]);\\n    return l;\\n  });\\n});\\nvar j = T((O, $) => {\\n  (function(e, t) {\\n    \\\"use strict\\\";\\n    typeof define == \\\"function\\\" && define.amd ? define(\\\"error-stack-parser\\\", [\\\"stackframe\\\"], t) : typeof O == \\\"object\\\" ? $.exports = t(U()) : e.ErrorStackParser = t(e.StackFrame);\\n  })(O, m(function(t) {\\n    \\\"use strict\\\";\\n    var s = /(^|@)\\\\S+:\\\\d+/, a = /^\\\\s*at .*(\\\\S+:\\\\d+|\\\\(native\\\\))/m, o = /^(eval@)?(\\\\[native code])?$/;\\n    return { parse: m(function(n) {\\n      if (typeof n.stacktrace < \\\"u\\\" || typeof n[\\\"opera#sourceloc\\\"] < \\\"u\\\")\\n        return this.parseOpera(n);\\n      if (n.stack && n.stack.match(a))\\n        return this.parseV8OrIE(n);\\n      if (n.stack)\\n        return this.parseFFOrSafari(n);\\n      throw new Error(\\\"Cannot parse given Error object\\\");\\n    }, \\\"ErrorStackParser$$parse\\\"), extractLocation: m(function(n) {\\n      if (n.indexOf(\\\":\\\") === -1)\\n        return [n];\\n      var c = /(.+?)(?::(\\\\d+))?(?::(\\\\d+))?$/, i = c.exec(n.replace(/[()]/g, \\\"\\\"));\\n      return [i[1], i[2] || void 0, i[3] || void 0];\\n    }, \\\"ErrorStackParser$$extractLocation\\\"), parseV8OrIE: m(function(n) {\\n      var c = n.stack.split(`\\n`).filter(function(i) {\\n        return !!i.match(a);\\n      }, this);\\n      return c.map(function(i) {\\n        i.indexOf(\\\"(eval \\\") > -1 && (i = i.replace(/eval code/g, \\\"eval\\\").replace(/(\\\\(eval at [^()]*)|(,.*$)/g, \\\"\\\"));\\n        var l = i.replace(/^\\\\s+/, \\\"\\\").replace(/\\\\(eval code/g, \\\"(\\\").replace(/^.*?\\\\s+/, \\\"\\\"), d = l.match(/ (\\\\(.+\\\\)$)/);\\n        l = d ? l.replace(d[0], \\\"\\\") : l;\\n        var p = this.extractLocation(d ? d[1] : l), f = d && l || void 0, u = [\\\"eval\\\", \\\"<anonymous>\\\"].indexOf(p[0]) > -1 ? void 0 : p[0];\\n        return new t({ functionName: f, fileName: u, lineNumber: p[1], columnNumber: p[2], source: i });\\n      }, this);\\n    }, \\\"ErrorStackParser$$parseV8OrIE\\\"), parseFFOrSafari: m(function(n) {\\n      var c = n.stack.split(`\\n`).filter(function(i) {\\n        return !i.match(o);\\n      }, this);\\n      return c.map(function(i) {\\n        if (i.indexOf(\\\" > eval\\\") > -1 && (i = i.replace(/ line (\\\\d+)(?: > eval line \\\\d+)* > eval:\\\\d+:\\\\d+/g, \\\":$1\\\")), i.indexOf(\\\"@\\\") === -1 && i.indexOf(\\\":\\\") === -1)\\n          return new t({ functionName: i });\\n        var l = /((.*\\\".+\\\"[^@]*)?[^@]*)(?:@)/, d = i.match(l), p = d && d[1] ? d[1] : void 0, f = this.extractLocation(i.replace(l, \\\"\\\"));\\n        return new t({ functionName: p, fileName: f[0], lineNumber: f[1], columnNumber: f[2], source: i });\\n      }, this);\\n    }, \\\"ErrorStackParser$$parseFFOrSafari\\\"), parseOpera: m(function(n) {\\n      return !n.stacktrace || n.message.indexOf(`\\n`) > -1 && n.message.split(`\\n`).length > n.stacktrace.split(`\\n`).length ? this.parseOpera9(n) : n.stack ? this.parseOpera11(n) : this.parseOpera10(n);\\n    }, \\\"ErrorStackParser$$parseOpera\\\"), parseOpera9: m(function(n) {\\n      for (var c = /Line (\\\\d+).*script (?:in )?(\\\\S+)/i, i = n.message.split(`\\n`), l = [], d = 2, p = i.length; d < p; d += 2) {\\n        var f = c.exec(i[d]);\\n        f && l.push(new t({ fileName: f[2], lineNumber: f[1], source: i[d] }));\\n      }\\n      return l;\\n    }, \\\"ErrorStackParser$$parseOpera9\\\"), parseOpera10: m(function(n) {\\n      for (var c = /Line (\\\\d+).*script (?:in )?(\\\\S+)(?:: In function (\\\\S+))?$/i, i = n.stacktrace.split(`\\n`), l = [], d = 0, p = i.length; d < p; d += 2) {\\n        var f = c.exec(i[d]);\\n        f && l.push(new t({ functionName: f[3] || void 0, fileName: f[2], lineNumber: f[1], source: i[d] }));\\n      }\\n      return l;\\n    }, \\\"ErrorStackParser$$parseOpera10\\\"), parseOpera11: m(function(n) {\\n      var c = n.stack.split(`\\n`).filter(function(i) {\\n        return !!i.match(s) && !i.match(/^Error created at/);\\n      }, this);\\n      return c.map(function(i) {\\n        var l = i.split(\\\"@\\\"), d = this.extractLocation(l.pop()), p = l.shift() || \\\"\\\", f = p.replace(/<anonymous function(: (\\\\w+))?>/, \\\"$2\\\").replace(/\\\\([^)]*\\\\)/g, \\\"\\\") || void 0, u;\\n        p.match(/\\\\(([^)]*)\\\\)/) && (u = p.replace(/^[^(]+\\\\(([^)]*)\\\\)$/, \\\"$1\\\"));\\n        var y = u === void 0 || u === \\\"[arguments not available]\\\" ? void 0 : u.split(\\\",\\\");\\n        return new t({ functionName: f, args: y, fileName: d[0], lineNumber: d[1], columnNumber: d[2], source: i });\\n      }, this);\\n    }, \\\"ErrorStackParser$$parseOpera11\\\") };\\n  }, \\\"ErrorStackParser\\\"));\\n});\\nvar V = ie(j());\\nvar _ = typeof process == \\\"object\\\" && typeof process.versions == \\\"object\\\" && typeof process.versions.node == \\\"string\\\" && typeof process.browser == \\\"undefined\\\", C, w, R, M, A;\\nasync function B() {\\n  if (!_ || (C = (await import(\\\"url\\\")).default, A = await import(\\\"fs/promises\\\"), globalThis.fetch ? w = fetch : w = (await import(\\\"node-fetch\\\")).default, M = (await import(\\\"vm\\\")).default, R = await import(\\\"path\\\"), E = R.sep, typeof L != \\\"undefined\\\"))\\n    return;\\n  let e = await import(\\\"fs\\\"), t = await import(\\\"crypto\\\"), s = await import(\\\"ws\\\"), a = await import(\\\"child_process\\\"), o = { fs: e, crypto: t, ws: s, child_process: a };\\n  ({});\\n}\\nm(B, \\\"initNodeModules\\\");\\nfunction oe(e, t) {\\n  return R.resolve(t || \\\".\\\", e);\\n}\\nm(oe, \\\"node_resolvePath\\\");\\nfunction ae(e, t) {\\n  return t === void 0 && (t = location), new URL(e, t).toString();\\n}\\nm(ae, \\\"browser_resolvePath\\\");\\nvar S;\\n_ ? S = oe : S = ae;\\nvar E;\\n_ || (E = \\\"/\\\");\\nfunction se(e, t) {\\n  return e.startsWith(\\\"file://\\\") && (e = e.slice(7)), e.includes(\\\"://\\\") ? { response: w(e) } : { binary: A.readFile(e).then((s) => new Uint8Array(s.buffer, s.byteOffset, s.byteLength)) };\\n}\\nm(se, \\\"node_getBinaryResponse\\\");\\nfunction le(e, t) {\\n  let s = new URL(e, location);\\n  return { response: fetch(s, t ? { integrity: t } : {}) };\\n}\\nm(le, \\\"browser_getBinaryResponse\\\");\\nvar v;\\n_ ? v = se : v = le;\\nasync function W(e, t) {\\n  let { response: s, binary: a } = v(e, t);\\n  if (a)\\n    return a;\\n  let o = await s;\\n  if (!o.ok)\\n    throw new Error(`Failed to load '${e}': request failed.`);\\n  return new Uint8Array(await o.arrayBuffer());\\n}\\nm(W, \\\"loadBinaryFile\\\");\\nvar h;\\nif (globalThis.document)\\n  h = m(async (e) => await import(e), \\\"loadScript\\\");\\nelse if (globalThis.importScripts)\\n  h = m(async (e) => {\\n    try {\\n      globalThis.importScripts(e);\\n    } catch (t) {\\n      if (t instanceof TypeError)\\n        await import(e);\\n      else\\n        throw t;\\n    }\\n  }, \\\"loadScript\\\");\\nelse if (_)\\n  h = de;\\nelse\\n  throw new Error(\\\"Cannot determine runtime environment\\\");\\nasync function de(e) {\\n  e.startsWith(\\\"file://\\\") && (e = e.slice(7)), e.includes(\\\"://\\\") ? M.runInThisContext(await (await w(e)).text()) : await import(C.pathToFileURL(e).href);\\n}\\nm(de, \\\"nodeLoadScript\\\");\\nfunction H(e) {\\n  let t = e.FS, s = e.FS.filesystems.MEMFS, a = e.PATH, o = { DIR_MODE: 16895, FILE_MODE: 33279, mount: function(r) {\\n    if (!r.opts.fileSystemHandle)\\n      throw new Error(\\\"opts.fileSystemHandle is required\\\");\\n    return s.mount.apply(null, arguments);\\n  }, syncfs: async (r, n, c) => {\\n    try {\\n      let i = o.getLocalSet(r), l = await o.getRemoteSet(r), d = n ? l : i, p = n ? i : l;\\n      await o.reconcile(r, d, p), c(null);\\n    } catch (i) {\\n      c(i);\\n    }\\n  }, getLocalSet: (r) => {\\n    let n = /* @__PURE__ */ Object.create(null);\\n    function c(d) {\\n      return d !== \\\".\\\" && d !== \\\"..\\\";\\n    }\\n    m(c, \\\"isRealDir\\\");\\n    function i(d) {\\n      return (p) => a.join2(d, p);\\n    }\\n    m(i, \\\"toAbsolute\\\");\\n    let l = t.readdir(r.mountpoint).filter(c).map(i(r.mountpoint));\\n    for (; l.length; ) {\\n      let d = l.pop(), p = t.stat(d);\\n      t.isDir(p.mode) && l.push.apply(l, t.readdir(d).filter(c).map(i(d))), n[d] = { timestamp: p.mtime, mode: p.mode };\\n    }\\n    return { type: \\\"local\\\", entries: n };\\n  }, getRemoteSet: async (r) => {\\n    let n = /* @__PURE__ */ Object.create(null), c = await ce(r.opts.fileSystemHandle);\\n    for (let [i, l] of c)\\n      i !== \\\".\\\" && (n[a.join2(r.mountpoint, i)] = { timestamp: l.kind === \\\"file\\\" ? (await l.getFile()).lastModifiedDate : /* @__PURE__ */ new Date(), mode: l.kind === \\\"file\\\" ? o.FILE_MODE : o.DIR_MODE });\\n    return { type: \\\"remote\\\", entries: n, handles: c };\\n  }, loadLocalEntry: (r) => {\\n    let c = t.lookupPath(r).node, i = t.stat(r);\\n    if (t.isDir(i.mode))\\n      return { timestamp: i.mtime, mode: i.mode };\\n    if (t.isFile(i.mode))\\n      return c.contents = s.getFileDataAsTypedArray(c), { timestamp: i.mtime, mode: i.mode, contents: c.contents };\\n    throw new Error(\\\"node type not supported\\\");\\n  }, storeLocalEntry: (r, n) => {\\n    if (t.isDir(n.mode))\\n      t.mkdirTree(r, n.mode);\\n    else if (t.isFile(n.mode))\\n      t.writeFile(r, n.contents, { canOwn: true });\\n    else\\n      throw new Error(\\\"node type not supported\\\");\\n    t.chmod(r, n.mode), t.utime(r, n.timestamp, n.timestamp);\\n  }, removeLocalEntry: (r) => {\\n    var n = t.stat(r);\\n    t.isDir(n.mode) ? t.rmdir(r) : t.isFile(n.mode) && t.unlink(r);\\n  }, loadRemoteEntry: async (r) => {\\n    if (r.kind === \\\"file\\\") {\\n      let n = await r.getFile();\\n      return { contents: new Uint8Array(await n.arrayBuffer()), mode: o.FILE_MODE, timestamp: n.lastModifiedDate };\\n    } else {\\n      if (r.kind === \\\"directory\\\")\\n        return { mode: o.DIR_MODE, timestamp: /* @__PURE__ */ new Date() };\\n      throw new Error(\\\"unknown kind: \\\" + r.kind);\\n    }\\n  }, storeRemoteEntry: async (r, n, c) => {\\n    let i = r.get(a.dirname(n)), l = t.isFile(c.mode) ? await i.getFileHandle(a.basename(n), { create: true }) : await i.getDirectoryHandle(a.basename(n), { create: true });\\n    if (l.kind === \\\"file\\\") {\\n      let d = await l.createWritable();\\n      await d.write(c.contents), await d.close();\\n    }\\n    r.set(n, l);\\n  }, removeRemoteEntry: async (r, n) => {\\n    await r.get(a.dirname(n)).removeEntry(a.basename(n)), r.delete(n);\\n  }, reconcile: async (r, n, c) => {\\n    let i = 0, l = [];\\n    Object.keys(n.entries).forEach(function(f) {\\n      let u = n.entries[f], y = c.entries[f];\\n      (!y || t.isFile(u.mode) && u.timestamp.getTime() > y.timestamp.getTime()) && (l.push(f), i++);\\n    }), l.sort();\\n    let d = [];\\n    if (Object.keys(c.entries).forEach(function(f) {\\n      n.entries[f] || (d.push(f), i++);\\n    }), d.sort().reverse(), !i)\\n      return;\\n    let p = n.type === \\\"remote\\\" ? n.handles : c.handles;\\n    for (let f of l) {\\n      let u = a.normalize(f.replace(r.mountpoint, \\\"/\\\")).substring(1);\\n      if (c.type === \\\"local\\\") {\\n        let y = p.get(u), g = await o.loadRemoteEntry(y);\\n        o.storeLocalEntry(f, g);\\n      } else {\\n        let y = o.loadLocalEntry(f);\\n        await o.storeRemoteEntry(p, u, y);\\n      }\\n    }\\n    for (let f of d)\\n      if (c.type === \\\"local\\\")\\n        o.removeLocalEntry(f);\\n      else {\\n        let u = a.normalize(f.replace(r.mountpoint, \\\"/\\\")).substring(1);\\n        await o.removeRemoteEntry(p, u);\\n      }\\n  } };\\n  e.FS.filesystems.NATIVEFS_ASYNC = o;\\n}\\nm(H, \\\"initializeNativeFS\\\");\\nvar ce = m(async (e) => {\\n  let t = [];\\n  async function s(o) {\\n    for await (let r of o.values())\\n      t.push(r), r.kind === \\\"directory\\\" && await s(r);\\n  }\\n  m(s, \\\"collect\\\"), await s(e);\\n  let a = /* @__PURE__ */ new Map();\\n  a.set(\\\".\\\", e);\\n  for (let o of t) {\\n    let r = (await e.resolve(o)).join(\\\"/\\\");\\n    a.set(r, o);\\n  }\\n  return a;\\n}, \\\"getFsHandles\\\");\\nfunction I() {\\n  let e = {};\\n  return e.noImageDecoding = true, e.noAudioDecoding = true, e.noWasmDecoding = false, e.preRun = [], e.quit = (t, s) => {\\n    throw e.exited = { status: t, toThrow: s }, s;\\n  }, e;\\n}\\nm(I, \\\"createModule\\\");\\nfunction ue(e, t) {\\n  e.preRun.push(function() {\\n    let s = \\\"/\\\";\\n    try {\\n      e.FS.mkdirTree(t);\\n    } catch (a) {\\n      console.error(`Error occurred while making a home directory '${t}':`), console.error(a), console.error(`Using '${s}' for a home directory instead`), t = s;\\n    }\\n    e.FS.chdir(t);\\n  });\\n}\\nm(ue, \\\"createHomeDirectory\\\");\\nfunction fe(e, t) {\\n  e.preRun.push(function() {\\n    Object.assign(e.ENV, t);\\n  });\\n}\\nm(fe, \\\"setEnvironment\\\");\\nfunction me(e, t) {\\n  e.preRun.push(() => {\\n    for (let s of t)\\n      e.FS.mkdirTree(s), e.FS.mount(e.FS.filesystems.NODEFS, { root: s }, s);\\n  });\\n}\\nm(me, \\\"mountLocalDirectories\\\");\\nfunction pe(e, t) {\\n  let s = W(t);\\n  e.preRun.push(() => {\\n    let a = e._py_version_major(), o = e._py_version_minor();\\n    e.FS.mkdirTree(\\\"/lib\\\"), e.FS.mkdirTree(`/lib/python${a}.${o}/site-packages`), e.addRunDependency(\\\"install-stdlib\\\"), s.then((r) => {\\n      e.FS.writeFile(`/lib/python${a}${o}.zip`, r);\\n    }).catch((r) => {\\n      console.error(\\\"Error occurred while installing the standard library:\\\"), console.error(r);\\n    }).finally(() => {\\n      e.removeRunDependency(\\\"install-stdlib\\\");\\n    });\\n  });\\n}\\nm(pe, \\\"installStdlib\\\");\\nfunction z(e, t) {\\n  let s;\\n  t.stdLibURL != null ? s = t.stdLibURL : s = t.indexURL + \\\"python_stdlib.zip\\\", pe(e, s), ue(e, t.env.HOME), fe(e, t.env), me(e, t._node_mounts), e.preRun.push(() => H(e));\\n}\\nm(z, \\\"initializeFileSystem\\\");\\nfunction G(e, t) {\\n  let { binary: s, response: a } = v(t + \\\"pyodide.asm.wasm\\\");\\n  e.instantiateWasm = function(o, r) {\\n    return async function() {\\n      try {\\n        let n;\\n        a ? n = await WebAssembly.instantiateStreaming(a, o) : n = await WebAssembly.instantiate(await s, o);\\n        let { instance: c, module: i } = n;\\n        typeof WasmOffsetConverter != \\\"undefined\\\" && (wasmOffsetConverter = new WasmOffsetConverter(wasmBinary, i)), r(c, i);\\n      } catch (n) {\\n        console.warn(\\\"wasm instantiation failed!\\\"), console.warn(n);\\n      }\\n    }(), {};\\n  };\\n}\\nm(G, \\\"preloadWasm\\\");\\nvar k = \\\"0.24.1\\\";\\nfunction ye(e, t) {\\n  return new Proxy(e, { get(s, a) {\\n    return a === \\\"get\\\" ? (o) => {\\n      let r = s.get(o);\\n      return r === void 0 && (r = t.get(o)), r;\\n    } : a === \\\"has\\\" ? (o) => s.has(o) || t.has(o) : Reflect.get(s, a);\\n  } });\\n}\\nm(ye, \\\"wrapPythonGlobals\\\");\\nfunction ge(e, t) {\\n  e.runPythonInternal_dict = e._pyodide._base.eval_code(\\\"{}\\\"), e.importlib = e.runPythonInternal(\\\"import importlib; importlib\\\");\\n  let s = e.importlib.import_module;\\n  e.sys = s(\\\"sys\\\"), e.sys.path.insert(0, t.env.HOME), e.os = s(\\\"os\\\");\\n  let a = e.runPythonInternal(\\\"import __main__; __main__.__dict__\\\"), o = e.runPythonInternal(\\\"import builtins; builtins.__dict__\\\");\\n  e.globals = ye(a, o);\\n  let r = e._pyodide._importhook;\\n  function n(i) {\\n    \\\"__all__\\\" in i || Object.defineProperty(i, \\\"__all__\\\", { get: () => c.toPy(Object.getOwnPropertyNames(i).filter((l) => l !== \\\"__all__\\\")), enumerable: false, configurable: true });\\n  }\\n  m(n, \\\"jsFinderHook\\\"), r.register_js_finder.callKwargs({ hook: n }), r.register_js_module(\\\"js\\\", t.jsglobals);\\n  let c = e.makePublicAPI();\\n  return r.register_js_module(\\\"pyodide_js\\\", c), e.pyodide_py = s(\\\"pyodide\\\"), e.pyodide_code = s(\\\"pyodide.code\\\"), e.pyodide_ffi = s(\\\"pyodide.ffi\\\"), e.package_loader = s(\\\"pyodide._package_loader\\\"), e.sitepackages = e.package_loader.SITE_PACKAGES.__str__(), e.dsodir = e.package_loader.DSO_DIR.__str__(), e.defaultLdLibraryPath = [e.dsodir, e.sitepackages], e.os.environ.__setitem__(\\\"LD_LIBRARY_PATH\\\", e.defaultLdLibraryPath.join(\\\":\\\")), c.pyodide_py = e.pyodide_py, c.globals = e.globals, c;\\n}\\nm(ge, \\\"finalizeBootstrap\\\");\\nfunction be() {\\n  if (typeof __dirname == \\\"string\\\")\\n    return __dirname;\\n  let e;\\n  try {\\n    throw new Error();\\n  } catch (a) {\\n    e = a;\\n  }\\n  let t = V.default.parse(e)[0].fileName, s = t.lastIndexOf(E);\\n  if (s === -1)\\n    throw new Error(\\\"Could not extract indexURL path from pyodide module location\\\");\\n  return t.slice(0, s);\\n}\\nm(be, \\\"calculateIndexURL\\\");\\nasync function De(e = {}) {\\n  await B();\\n  let t = e.indexURL || be();\\n  t = S(t), t.endsWith(\\\"/\\\") || (t += \\\"/\\\"), e.indexURL = t;\\n  let s = { fullStdLib: false, jsglobals: globalThis, stdin: globalThis.prompt ? globalThis.prompt : void 0, lockFileURL: t + \\\"pyodide-lock.json\\\", args: [], _node_mounts: [], env: {}, packageCacheDir: t, packages: [] }, a = Object.assign(s, e);\\n  if (e.homedir) {\\n    if (console.warn(\\\"The homedir argument to loadPyodide is deprecated. Use 'env: { HOME: value }' instead of 'homedir: value'.\\\"), e.env && e.env.HOME)\\n      throw new Error(\\\"Set both env.HOME and homedir arguments\\\");\\n    a.env.HOME = a.homedir;\\n  }\\n  a.env.HOME || (a.env.HOME = \\\"/home/pyodide\\\");\\n  let o = I();\\n  o.print = a.stdout, o.printErr = a.stderr, o.arguments = a.args;\\n  let r = { config: a };\\n  o.API = r, G(o, t), z(o, a);\\n  let n = new Promise((f) => o.postRun = f), c;\\n  if (r.bootstrapFinalizedPromise = new Promise((f) => c = f), o.locateFile = (f) => a.indexURL + f, typeof _createPyodideModule != \\\"function\\\") {\\n    let f = `${a.indexURL}pyodide.asm.js`;\\n    await h(f);\\n  }\\n  if (await _createPyodideModule(o), await n, o.exited)\\n    throw o.exited.toThrow;\\n  if (r.version !== k)\\n    throw new Error(`Pyodide version does not match: '${k}' <==> '${r.version}'. If you updated the Pyodide version, make sure you also updated the 'indexURL' parameter passed to loadPyodide.`);\\n  o.locateFile = (f) => {\\n    throw new Error(\\\"Didn't expect to load any more file_packager files!\\\");\\n  };\\n  let [i, l] = r.rawRun(\\\"import _pyodide_core\\\");\\n  i && o.API.fatal_loading_error(`Failed to import _pyodide_core\\n`, l);\\n  let d = ge(r, a);\\n  if (c(), d.version.includes(\\\"dev\\\") || r.setCdnUrl(`https://cdn.jsdelivr.net/pyodide/v${d.version}/full/`), await r.packageIndexReady, r._pyodide._importhook.register_module_not_found_hook(r._import_name_to_package_name, r.lockfile_unvendored_stdlibs_and_test), r.lockfile_info.version !== k)\\n    throw new Error(\\\"Lock file version doesn't match Pyodide version\\\");\\n  return r.package_loader.init_loaded_packages(), a.fullStdLib && await d.loadPackage(r.lockfile_unvendored_stdlibs), r.initializeStreams(a.stdin, a.stdout, a.stderr), d;\\n}\\nm(De, \\\"loadPyodide\\\");\\nmodule.exports;\\n\");\nexport const loadPyodide = out.loadPyodide;\nexport const version = out.version;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.p = \"/pybricks-code/\";","__webpack_require__.b = self.location + \"/../../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t8760: 1\n};\n\n// no chunk install function needed\n// no chunk loading\n\n// no HMR\n\n// no HMR manifest","// SPDX-License-Identifier: MIT\n// Copyright (c) 2020-2022 The Pybricks Authors\n\n/**\n * Asserts that an assumption is true. This is used to detect programmer errors\n * and should never actually throw in a correctly written program.\n * @param condition A condition that is assumed to be true\n * @param message Informational message for debugging\n */\nexport function assert(condition: boolean, message: string): asserts condition {\n    if (!condition) {\n        throw Error(message);\n    }\n}\n\n/**\n * Asserts that an object is not undefined. This is used to make the type\n * checker happy with `maybe()` and saga `race()` and `all()` effects where\n * we have the condition \"if A is undefined, then B is not undefined\".\n */\nexport function defined<T>(obj: T): asserts obj is NonNullable<T> {\n    assert(obj !== undefined, 'undefined object');\n    assert(obj !== null, 'null object');\n}\n\nexport type Maybe<T> = [T?, Error?];\n\n/** Wraps a promise in try/catch and returns the promise result or error. */\nexport async function maybe<T>(promise: Promise<T>): Promise<Maybe<T>> {\n    try {\n        return [await promise];\n    } catch (err) {\n        return [undefined, ensureError(err)];\n    }\n}\n\n/**\n * Formats a number as hex (0x00...)\n * @param n The number to format\n * @param pad The total number of digits padded with leading 0s\n */\nexport function hex(n: number, pad: number): string {\n    return `0x${n.toString(16).padStart(pad, '0')}`;\n}\n\nfunction isError(err: unknown): err is Error {\n    const maybeError = err as Error;\n\n    return (\n        maybeError !== undefined &&\n        typeof maybeError.name === 'string' &&\n        typeof maybeError.message === 'string'\n    );\n}\n\nexport function ensureError(err: unknown): Error {\n    if (isError(err)) {\n        return err;\n    }\n\n    if (typeof err === 'string') {\n        return new Error(err);\n    }\n\n    return Error(String(err));\n}\n\n/**\n * Gets a timestamp with second resolution suitable for use in a filename.\n */\nexport function timestamp(): string {\n    return new Date()\n        .toISOString()\n        .replace('T', '_')\n        .replaceAll(':', '-')\n        .replace(/\\..*$/, '');\n}\n\n/**\n * Helper function to wrap navigator.locks in a promise so that it can be used\n * in code where using it natively doesn't work well (e.g. in sagas). Care must\n * be taken so that all code paths (including exceptions) release the lock.\n *\n * To release the lock, await the returned release function. When the release\n * function resolves, the lock will no longer be held.\n *\n * @param name The name of the lock.\n * @param shared If true, the lock will be share (e.g. for reading), otherwise\n * the lock will be exclusive (e.g. for writing).\n * @returns A release function if the lock was acquired or nothing if the lock\n * was already held exclusively by someone else.\n */\nexport async function acquireLock(\n    name: string,\n    shared?: boolean,\n): Promise<(() => Promise<void>) | void> {\n    let lockWaiter: Promise<void>;\n\n    const release = await new Promise<(() => void) | void>((resolve, reject) => {\n        lockWaiter = navigator.locks\n            .request(\n                name,\n                {\n                    ifAvailable: true,\n                    mode: shared ? 'shared' : 'exclusive',\n                },\n                (lock) => {\n                    // if the locks is already held, lock will be null here\n                    if (lock === null) {\n                        resolve();\n                        return;\n                    }\n\n                    // Now we own the lock and it will be held until the returned\n                    // promise is resolved.\n                    return new Promise<void>((resolve2) => resolve(resolve2));\n                },\n            )\n            .catch(reject);\n    });\n\n    if (!release) {\n        return;\n    }\n\n    return async () => {\n        // trigger the release\n        release();\n        // then wait until the release is complete and the lock is no longer held\n        await lockWaiter;\n    };\n}\n","// SPDX-License-Identifier: MIT\n// Copyright (c) 2022 The Pybricks Authors\n\nimport { AnyAction } from 'redux';\n\n/** A function that creates action objects. */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype ActionCreationFunction<A extends AnyAction> = (...args: any[]) => A;\n\n/** A function that performs type discrimination on an action. */\ntype MatchFunction<A extends AnyAction> = (action: AnyAction) => action is A;\n\n/** The extra members that are attached to a function by createAction(). */\ntype MatchableExtensions<F extends ActionCreationFunction<A>, A extends AnyAction> = {\n    /**\n     * This should not usually be used directly. It allows Matchable action\n     * functions to be passed directly to redux saga effects as an action pattern.\n     */\n    toString(): ReturnType<F>['type'];\n    /**\n     * Type guard to ensure an action matches this type.\n     */\n    matches: MatchFunction<ReturnType<F>>;\n    /**\n     * Type guard creation function with addition filtering.\n     *\n     * This is useful for creating a guard function to pass to redux saga\n     * effects.\n     *\n     * @example const action = yield* take(someAction.when((a) => a.property === value));\n     *\n     * @param predicate An predicate to filter actions.\n     */\n    when(predicate: (action: ReturnType<F>) => boolean): MatchFunction<ReturnType<F>>;\n};\n\n/** An action creation function that includes MatchableExtensions. */\ntype Matchable<F extends ActionCreationFunction<A>, A extends AnyAction> = F &\n    MatchableExtensions<F, A>;\n\n/**\n * Adds additional members to an action creation function.\n *\n * @param actionCreator The action creation function.\n * @returns actionCreator with type property and match method added.\n */\nexport function createAction<\n    F extends ActionCreationFunction<A>,\n    A extends AnyAction = ReturnType<F>,\n>(actionCreator: F): Matchable<F, A> {\n    // create a default action so we can get the type string.\n    const type = actionCreator().type;\n\n    function matches(action: AnyAction): action is ReturnType<F> {\n        return action.type === type;\n    }\n\n    function when(\n        predicate: (action: ReturnType<F>) => boolean,\n    ): MatchFunction<ReturnType<F>> {\n        return (a: AnyAction): a is ReturnType<F> => {\n            if (!matches(a)) {\n                return false;\n            }\n\n            return predicate(a);\n        };\n    }\n\n    return Object.assign(actionCreator, <MatchableExtensions<F, A>>{\n        toString: () => type,\n        matches,\n        when,\n    });\n}\n","// SPDX-License-Identifier: MIT\n// Copyright (c) 2022 The Pybricks Authors\n\nimport { createAction } from '../actions';\n\n// NB: although we are using the same action creator as we do for redux, these\n// actions are not used by redux but rather are to sent between workers.\n\n/**\n * Message sent from main to work to request initialization of Pyodide.\n */\nexport const pythonMessageInit = createAction(() => ({\n    type: 'python.message.init',\n}));\n\n/**\n * Message sent from worker to main that indicates {@link pythonMessageInit}\n * succeeded.\n */\nexport const pythonMessageDidInit = createAction(() => ({\n    type: 'python.message.didInit',\n}));\n\n/**\n * Message sent from worker to main that indicates {@link pythonMessageInit}\n * failed.\n */\nexport const pythonMessageDidFailToInit = createAction((error: Error) => ({\n    type: 'python.message.didFailToInit',\n    error,\n}));\n\n/**\n * Message sent from main to worker to set the shared interrupt buffer.\n */\nexport const pythonMessageSetInterruptBuffer = createAction((buffer: Uint8Array) => ({\n    type: 'python.message.setInterruptBuffer',\n    buffer,\n}));\n\n/**\n * Message sent from main to worker to request code completion.\n */\nexport const pythonMessageComplete = createAction(\n    (code: string, lineNumber: number, column: number) => ({\n        type: 'python.message.complete',\n        code,\n        lineNumber,\n        column,\n    }),\n);\n\n/**\n * Message sent from worker to main that indicates {@link pythonMessageComplete}\n * succeeded.\n */\nexport const pythonMessageDidComplete = createAction((completionListJson: string) => ({\n    type: 'python.message.didComplete',\n    completionListJson,\n}));\n\n/**\n * Message sent from worker to main that indicates {@link pythonMessageComplete}\n * failed.\n */\nexport const pythonMessageDidFailToComplete = createAction((error: Error) => ({\n    type: 'python.message.didFailToComplete',\n    error,\n}));\n\n/**\n * Message sent from main to worker to request function signature.\n */\nexport const pythonMessageGetSignature = createAction(\n    (code: string, lineNumber: number, column: number) => ({\n        type: 'python.message.getSignature',\n        code,\n        lineNumber,\n        column,\n    }),\n);\n\n/**\n * Message sent from worker to main that indicates {@link pythonMessageGetSignature}\n * succeeded.\n */\nexport const pythonMessageDidGetSignature = createAction(\n    (signatureHelpJson: string) => ({\n        type: 'python.message.didGetSignature',\n        signatureHelpJson,\n    }),\n);\n\n/**\n * Message sent from worker to main that indicates {@link pythonMessageGetSignature}\n * failed.\n */\nexport const pythonMessageDidFailToGetSignature = createAction((error: Error) => ({\n    type: 'python.message.didFailToGetSignature',\n    error,\n}));\n\nexport const pythonMessageWriteUserFile = createAction(\n    (path: string, contents: string) => ({\n        type: 'python.message.writeUserFile',\n        path,\n        contents,\n    }),\n);\n\nexport const pythonMessageDeleteUserFile = createAction((path: string) => ({\n    type: 'python.message.deleteUserFile',\n    path,\n}));\n\nexport const pythonMessageDidMountUserFileSystem = createAction(() => ({\n    type: 'python.message.didMountUserFileSystem',\n}));\n","// SPDX-License-Identifier: MIT\n// Copyright (c) 2022-2023 The Pybricks Authors\n\n// This file runs as a web worker.\n\n// NB: We need to be very careful about imports here since many libraries for\n// web aren't compatible with web workers!\n\nimport { loadPyodide, version as pyodideVersion } from 'pyodide';\nimport type { PythonError } from 'pyodide/ffi';\nimport { ensureError } from '../utils';\nimport {\n    pythonMessageComplete,\n    pythonMessageDeleteUserFile,\n    pythonMessageDidComplete,\n    pythonMessageDidFailToComplete,\n    pythonMessageDidFailToGetSignature,\n    pythonMessageDidFailToInit,\n    pythonMessageDidGetSignature,\n    pythonMessageDidInit,\n    pythonMessageDidMountUserFileSystem,\n    pythonMessageGetSignature,\n    pythonMessageInit,\n    pythonMessageSetInterruptBuffer,\n    pythonMessageWriteUserFile,\n} from './python-message';\n\nfunction isPythonError(err: Error): err is PythonError {\n    return err.constructor.name === 'PythonError';\n}\n\n/**\n * Wrapper around {@link ensureError} that also converts KeyboardInterrupt to\n * AbortError.\n * @param err The value from the catch clause.\n * @returns The fixed up error.\n */\nfunction fixUpError(err: unknown): Error {\n    const error = ensureError(err);\n\n    if (isPythonError(error) && error.type === 'KeyboardInterrupt') {\n        return new DOMException('cancelled via KeyboardInterrupt', 'AbortError');\n    }\n\n    return error;\n}\n\n/**\n * Naively converts a file system path to a python module name.\n *\n * Assumes `.py` file extension and no invalid characters.\n *\n * @param path The path.\n */\nfunction pathToModule(path: string): string {\n    return path.slice(0, path.length - 3).replaceAll('/', '.');\n}\n\nconst setUpPythonEnvironment = `\nimport jedi\nimport pybricks_jedi\n\nprint('preloading pybricks_jedi...')\npybricks_jedi.initialize()\n# TODO: this could be moved to pybricks_jedi.initialize()\npybricks_jedi.complete(\"from \", 1, 6)\nprint('preloading done.')\n`;\n\nasync function init(): Promise<void> {\n    console.log('starting Pyodide...');\n\n    const pyodide = await loadPyodide({ indexURL: `pyodide/${pyodideVersion}` });\n\n    // REVISIT: it would be nice if we could make a custom driver to mount\n    // the custom Pybricks Code Dexie-based file system directly instead of\n    // mirroring it\n    const mountDir = '/user';\n    pyodide.FS.mkdir(mountDir);\n    pyodide.FS.mount(pyodide.FS.filesystems.MEMFS, { root: '.' }, mountDir);\n\n    const userModules = new Set<string>();\n\n    self.addEventListener('message', async (e) => {\n        if (pythonMessageWriteUserFile.matches(e.data)) {\n            pyodide.FS.writeFile(`${mountDir}/${e.data.path}`, e.data.contents);\n            console.debug('copied', e.data.path, 'to emscripten fs');\n            userModules.add(pathToModule(e.data.path));\n            return;\n        }\n\n        if (pythonMessageDeleteUserFile.matches(e.data)) {\n            pyodide.FS.unlink(`${mountDir}/${e.data.path}`);\n            console.debug('removed', e.data.path, ' from emscripten fs');\n            userModules.delete(pathToModule(e.data.path));\n            return;\n        }\n    });\n\n    // separate message for file system ready since it takes a long time for\n    // the rest of the init\n    self.postMessage(pythonMessageDidMountUserFileSystem());\n\n    // add user directory to sys.path for code completion\n    await pyodide.runPythonAsync(`import sys; sys.path.append(\"${mountDir}\")`);\n\n    // NB: using URL+import.meta.url for webpack magic - don't try to optimize it\n    await pyodide.loadPackage([\n        new URL('@pybricks/jedi/docstring-parser.whl', import.meta.url).toString(),\n        new URL('@pybricks/jedi/jedi.whl', import.meta.url).toString(),\n        new URL('@pybricks/jedi/parso.whl', import.meta.url).toString(),\n        new URL('@pybricks/jedi/pybricks_jedi.whl', import.meta.url).toString(),\n        new URL('@pybricks/jedi/pybricks.whl', import.meta.url).toString(),\n        new URL('@pybricks/jedi/typing_extensions.whl', import.meta.url).toString(),\n    ]);\n\n    await pyodide.runPythonAsync(setUpPythonEnvironment);\n\n    const complete = pyodide.runPython('pybricks_jedi.complete');\n    const getSignatures = pyodide.runPython('pybricks_jedi.get_signatures');\n    const updateUserModules = pyodide.runPython('pybricks_jedi.update_user_modules');\n\n    self.addEventListener('message', async (e) => {\n        if (pythonMessageSetInterruptBuffer.matches(e.data)) {\n            pyodide.setInterruptBuffer(e.data.buffer);\n            return;\n        }\n\n        if (pythonMessageComplete.matches(e.data)) {\n            console.debug('worker received complete message');\n            try {\n                updateUserModules(userModules);\n                const { code, lineNumber, column } = e.data;\n                const list = complete(code, lineNumber, column);\n                self.postMessage(pythonMessageDidComplete(list));\n            } catch (err) {\n                self.postMessage(pythonMessageDidFailToComplete(fixUpError(err)));\n            }\n            return;\n        }\n\n        if (pythonMessageGetSignature.matches(e.data)) {\n            console.debug('worker received getSignatures message');\n            try {\n                updateUserModules(userModules);\n                const { code, lineNumber, column } = e.data;\n                const list = getSignatures(code, lineNumber, column);\n                self.postMessage(pythonMessageDidGetSignature(list));\n            } catch (err) {\n                self.postMessage(pythonMessageDidFailToGetSignature(fixUpError(err)));\n            }\n            return;\n        }\n    });\n\n    console.log('Pyodide is ready.');\n}\n\nself.addEventListener('message', async (e) => {\n    if (pythonMessageInit.matches(e.data)) {\n        try {\n            await init();\n            postMessage(pythonMessageDidInit());\n        } catch (err) {\n            postMessage(pythonMessageDidFailToInit(ensureError(err)));\n        }\n    }\n});\n"],"names":["out","eval","loadPyodide","version","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","m","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","p","b","self","location","ensureError","err","maybeError","name","message","isError","Error","String","createAction","actionCreator","type","matches","action","assign","toString","when","predicate","a","pythonMessageInit","pythonMessageDidInit","pythonMessageDidFailToInit","error","pythonMessageSetInterruptBuffer","buffer","pythonMessageComplete","code","lineNumber","column","pythonMessageDidComplete","completionListJson","pythonMessageDidFailToComplete","pythonMessageGetSignature","pythonMessageDidGetSignature","signatureHelpJson","pythonMessageDidFailToGetSignature","pythonMessageWriteUserFile","path","contents","pythonMessageDeleteUserFile","pythonMessageDidMountUserFileSystem","fixUpError","constructor","isPythonError","DOMException","pathToModule","slice","length","replaceAll","addEventListener","async","e","data","console","log","pyodide","indexURL","pyodideVersion","mountDir","FS","mkdir","mount","filesystems","MEMFS","root","userModules","Set","writeFile","debug","add","unlink","delete","postMessage","runPythonAsync","loadPackage","URL","complete","runPython","getSignatures","updateUserModules","setInterruptBuffer","list","init"],"sourceRoot":""}