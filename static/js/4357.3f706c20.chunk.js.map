{"version":3,"file":"static/js/4357.3f706c20.chunk.js","mappings":"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","sources":["terminal/actions.ts","terminal/sagas.ts"],"sourcesContent":["// SPDX-License-Identifier: MIT\n// Copyright (c) 2020,2022 The Pybricks Authors\n\nimport { createAction } from '../actions';\n\nexport const sendData = createAction((data: string) => ({\n    type: 'terminal.action.sendData',\n    value: data,\n}));\n\nexport const receiveData = createAction((data: string) => ({\n    type: 'terminal.action.receiveData',\n    value: data,\n}));\n","// SPDX-License-Identifier: MIT\n// Copyright (c) 2020-2024 The Pybricks Authors\n\nimport { AnyAction } from 'redux';\nimport {\n    actionChannel,\n    delay,\n    fork,\n    getContext,\n    put,\n    race,\n    select,\n    take,\n    takeEvery,\n} from 'typed-redux-saga/macro';\nimport {\n    didFailToWrite,\n    didNotify,\n    didWrite,\n    write,\n} from '../ble-nordic-uart-service/actions';\nimport { nordicUartSafeTxCharLength } from '../ble-nordic-uart-service/protocol';\nimport {\n    didFailToSendCommand,\n    didReceiveWriteStdout,\n    didSendCommand,\n    sendWriteStdinCommand,\n} from '../ble-pybricks-service/actions';\nimport { checksum, hubDidStartRepl } from '../hub/actions';\nimport { HubRuntimeState } from '../hub/reducers';\nimport { RootState } from '../reducers';\nimport { assert, defined } from '../utils';\nimport { TerminalContextValue } from './TerminalContext';\nimport { receiveData, sendData } from './actions';\n\n/**\n * Partial saga context type for context used in the terminal sagas.\n */\nexport type TerminalSagaContext = { terminal: TerminalContextValue };\n\nconst encoder = new TextEncoder();\nconst uartDecoder = new TextDecoder();\nconst stdoutDecoder = new TextDecoder();\n\nfunction* receiveUartData(action: ReturnType<typeof didNotify>): Generator {\n    const { runtime: hubState, useLegacyStdio } = yield* select(\n        (s: RootState) => s.hub,\n    );\n\n    if (!useLegacyStdio) {\n        return;\n    }\n\n    if (hubState === HubRuntimeState.Loading && action.value.buffer.byteLength === 1) {\n        const view = new DataView(action.value.buffer);\n        yield* put(checksum(view.getUint8(0)));\n        return;\n    }\n\n    const value = uartDecoder.decode(action.value.buffer, { stream: true });\n    yield* put(sendData(value));\n}\n\nfunction* handleReceiveWriteStdout(\n    action: ReturnType<typeof didReceiveWriteStdout>,\n): Generator {\n    const value = stdoutDecoder.decode(action.payload, { stream: true });\n    yield* put(sendData(value));\n}\n\nfunction* receiveTerminalData(): Generator {\n    const nextMessageId = yield* getContext<() => number>('nextMessageId');\n    const channel = yield* actionChannel(receiveData);\n\n    for (;;) {\n        // wait for input from terminal\n        const action = yield* take(channel);\n        let value = action.value;\n\n        // Try to collect more data so that we aren't sending just one byte at time\n        while (value.length < nordicUartSafeTxCharLength) {\n            const { action, timeout } = yield* race({\n                action: take(channel),\n                timeout: delay(20),\n            });\n            if (timeout) {\n                break;\n            }\n            defined(action);\n            value += action.value;\n        }\n\n        const isUserProgramRunning = yield* select(\n            (s: RootState) => s.hub.runtime === HubRuntimeState.Running,\n        );\n\n        // REVISIT: this test is a bit dangerous since it is not actually\n        // testing that handleWriteUart in ble/sagas is running. In theory\n        // it should be fine as long a the logic for the state doesn't change.\n        if (!isUserProgramRunning) {\n            // if no user program is running, input goes to /dev/null\n            // print the BEL character (^G) to notify the user that the input was ignored\n            yield* put(sendData('\\x07'));\n            continue;\n        }\n\n        // stdin gets piped to BLE connection\n        const data = encoder.encode(value);\n\n        const { useLegacyStdio, maxBleWriteSize } = yield* select(\n            (s: RootState) => s.hub,\n        );\n\n        if (useLegacyStdio) {\n            for (let i = 0; i < data.length; i += nordicUartSafeTxCharLength) {\n                const { id } = yield* put(\n                    write(\n                        nextMessageId(),\n                        data.slice(i, i + nordicUartSafeTxCharLength),\n                    ),\n                );\n\n                yield* take(\n                    (a: AnyAction) =>\n                        (didWrite.matches(a) || didFailToWrite.matches(a)) &&\n                        a.id === id,\n                );\n\n                // wait for echo so tht we don't overrun the hub with messages\n                yield* race([take(didNotify), delay(100)]);\n            }\n        } else {\n            // maxBleWriteSize should always be set to a valid value when useLegacyStdio is false\n            assert(maxBleWriteSize >= 20, 'bad maxBleWriteSize');\n\n            for (let i = 0; i < data.length; i += maxBleWriteSize) {\n                const { id } = yield* put(\n                    sendWriteStdinCommand(\n                        nextMessageId(),\n                        data.slice(i, i + maxBleWriteSize),\n                    ),\n                );\n\n                const { didFail } = yield* race({\n                    didSucceed: take(didSendCommand.when((a) => a.id === id)),\n                    didFail: take(didFailToSendCommand.when((a) => a.id === id)),\n                });\n\n                if (didFail) {\n                    // istanbul ignore if\n                    if (process.env.NODE_ENV !== 'test') {\n                        console.error(didFail.error);\n                    }\n\n                    // REVISIT: should we provide UI feedback?\n                    // could echo BEL character as above\n                }\n            }\n        }\n    }\n}\n\nfunction* sendTerminalData(action: ReturnType<typeof sendData>): Generator {\n    const { dataSource } = yield* getContext<TerminalContextValue>('terminal');\n    // This is used to provide a data source for the Terminal component\n    dataSource.next(action.value);\n}\n\nfunction handleHubDidStartRepl(): void {\n    dispatchEvent(new CustomEvent('pb-terminal-focus'));\n}\n\nexport default function* (): Generator {\n    yield* takeEvery(didNotify, receiveUartData);\n    yield* takeEvery(didReceiveWriteStdout, handleReceiveWriteStdout);\n    yield* fork(receiveTerminalData);\n    yield* takeEvery(sendData, sendTerminalData);\n    yield* takeEvery(hubDidStartRepl, handleHubDidStartRepl);\n}\n"],"names":["sendData","createAction","data","type","value","receiveData","encoder","TextEncoder","uartDecoder","TextDecoder","stdoutDecoder","receiveUartData","action","runtime","hubState","useLegacyStdio","select","s","hub","HubRuntimeState","Loading","buffer","byteLength","view","DataView","put","checksum","getUint8","decode","stream","handleReceiveWriteStdout","payload","receiveTerminalData","nextMessageId","getContext","channel","actionChannel","take","length","nordicUartSafeTxCharLength","timeout","race","delay","defined","Running","encode","maxBleWriteSize","i","id","write","slice","a","didWrite","matches","didFailToWrite","didNotify","assert","sendWriteStdinCommand","didFail","didSucceed","didSendCommand","when","didFailToSendCommand","console","error","sendTerminalData","dataSource","next","handleHubDidStartRepl","dispatchEvent","CustomEvent","takeEvery","didReceiveWriteStdout","fork","hubDidStartRepl"],"sourceRoot":""}